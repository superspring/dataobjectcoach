<?php

/**
 * Provides a functionality to export virtual classes to code.
 */

class DataObjectCoach_Exporter extends DataExtension {

	/**
	 * Prepare constants.
	 */
	const CMD_EXPORT = 'export';
	const COMMENTBLOCK = <<<EOF
<?php
/**
 * This code has been automatically generated by the DataObjectCoach module.
 */

EOF;

	/**
	 * Tell sake more about this command.
	 */
	public function commands(&$list) {
		$list[self::CMD_EXPORT] = array($this, 'prepareExport', true);
	}

	/**
	 * Gives sake a brief for the help section.
	 */
	public function help_brief(&$details) {
		$details[self::CMD_EXPORT] = 'Provides the ability to export virtual classes to code.';
	}

	/**
	 * Gives sake a list of the parameters used.
	 */
	public function help_parameters(&$details) {
		$details[self::CMD_EXPORT] = array(
			'The first argument must be the module to export the code to',
			'--stdout - If this is the first argument code will go to stdout instead of a module',
			'Next argument/s may be the virtual class names to export',
			'--all - All virtual classes in the database',
		);
	}

	/**
	 * Gives sake a list of examples of how to use this command.
	 */
	public function help_examples(&$examples) {
		$examples[self::CMD_EXPORT] = array(
			self::CMD_EXPORT . ' --stdout --all - Outputs all virtual classes to stdout',
			self::CMD_EXPORT . ' mysite testClass1 testClass2 - Outputs the testClasses into the mysite module',
		);
	}

	/**
	 * Reads the commands to determine how to output the classes'.
	 */
	public function prepareExport($args) {

		// Check for errors.
		if (empty($args)) {
			return $this->showError('Expected either --stdout or a module for the first argument');
		}

		// Prepare variables.
		$module = array_shift($args);
		$classes = $args;

		// Which classes to export?
		if (reset($classes) == '--all') {
			$classes = DataObjectCoach_Container::get()->map('RawClassName', 'RawClassName');
		}

		// Put the files into the module.
		$this->exportModule($module, $classes);
	}

	/**
	 * Export the given classes into the module.
	 *
	 * If the module already exists, offer to diff the module.
	 */
	protected function exportModule($modulename, $classes) {

		// Is this going into a module or stdout?
		$display_output = $modulename == '--stdout';

		// Show the output instead.
		if ($display_output) {
			foreach ($classes as $class) {

				// Output to stdout.
				printf("%s\n", $this->generateCode($class));
			}

			// Extra lines to go into the _config.php file?
			$configcode = $this->getExtraConfig();

			// Output to stdout.
			printf("%s\n", $configcode);
		}
		else {
			// Sake is run inside the framework directory, so go one up.
			$prefix = '..';

			// Ensure all the directories exist.
			$this->createDirectory($prefix, $modulename);

			// Create a temporary file for each class.
			foreach ($classes as $class) {

				// Write the code.
				$code = $this->generateCode($class);

				// Generate the class.
				if (!$this->wrtieCode($modulename, $class, $code)) {

					// Was there an error?
					return false;
				}
			}

			// Extra lines to go into the _config.php file?
			$configcode = $this->getExtraConfig();

			// Generate the config file.
			$this->writeConfig($modulename, $configcode);
		}
	}

	/**
	 * Generate the code for the file.
	 */
	protected function writeCode($modulename, $class, $code) {

		// Generate the filename for this code.
		$file = sprintf('../%s/code/coach', $modulename);

		// Done.
		return $this->writeDiff($class, $file, $code);
	}

	/**
	 * Generate the config file for the module.
	 */
	protected function writeConfig($modulename, $config) {

		// Generate the filename for this code.
		$file = sprintf('../%s/_config.php', $modulename);

		// Done.
		return $this->writeDiff('_config', $file, $config);
	}

	/**
	 * Writes code to a temporary file and tries to diff against the original.
	 */
	protected function writeDiff($class, $file, $code) {

		// If the file exists, do a diff.
		if (file_exists($file)) {

			// Create a temporary file.
			$temp = sys_get_temp_dir() . '/a_file.php';
			@file_put_contents($temp, $code);
			if (!file_exists($temp)) {

				// Unable to write the file.
				$this->showError('Unable to write to temp directory');
				return false;
			}

			// Diff the files.
			if (md5_file($temp) != md5_file($file)) {

				// The files are different? Ask the user if it's ok.
				$patch = sys_get_temp_dir() . '/a_file.patch';
				if (!xdiff_file_diff($file, $temp, $patch, 100)) {

					// Unable to diff the files.
					$this->showError('Unable to generate patch file');
					return false;
				}

				// Show this to the user.
				shell_exec(sprintf('less "%s"', escapeshellarg($patch)));

				// Ask the user if 'we' should overwrite.
				printf('Overwrite the %s class with the changes? (y/n): ', $class);
				$handle = fopen('php://stdin', 'r');
				$line = fgets($handle);
				fclose($handle);
				if (trim($line) != 'y') {

					// Don't overwrite this file.
					printf("\nSkipping...\n");
					return true;
				}
			}

			// Delete the temp file.
			unlink($temp);
		}

		// If we've reached here, the diff is ok or a diff is not required.
		@file_put_contents($file, $code);
		if (!file_exists($file)) {

			// Unable to write the file.
			$this->showError('Unable to write to the module directory');
			return false;
		}

		// Done.
		return true;
	}

	/**
	 * Create the new/existing module's directory.
	 */
	protected function createDirectory($prefix, $module) {

		// Create the module directory.
		$module = strtolower($module);
		$paths = array(
			sprintf('%s/%s', $prefix, $module),
			sprintf('%s/%s/code', $prefix, $module),
			sprintf('%s/%s/code/coach', $prefix, $module),
		);

		// Ensure all directories exist.
		foreach($paths as $path) {

			// Does this path already exist?
			if (!file_exists($path)) {
				$success = @mkdir($path);

				// Is there a problem writing it?
				if (!$success) {
					printf("Unable to write directory: %s\n", $path);
					return false;
				}
			}
		}
	}

	/**
	 * Displays errors.
	 */
	protected function showError($msg) {
		printf("%s\n", $msg);
	}

	/**
	 * Generates the code for a virtual class.
	 *
	 * @param string $class
	 *   The name of a virtual class to generate code for.
	 *
	 * @return string
	 *   PHP code for the given class.
	 */
	protected function generateCode($class) {

		// Is this a purely virtual class or adding on to an existing one?
		if (property_exists($class, 'VIRTUALCLASS')) {
			return $this->generateVirtualCode($class);
		}
		else {
			return $this->generateAdditionalCode($class);
		}
	}

	/**
	 * Gets the variables required for a given class.
	 *
	 * @param string $class
	 *   The name of the class to query.
	 */
	protected function getClassVariables($class) {

		// Load the variables.
		$classobj = DataObjectCoach_Container::get()->filter(array(
			'RawClassName' => $class,
		))->first();
		$variables = array();

		// Go through each of the fields in this class.
		foreach ($classobj->Fields() as $field) {
			if (!array_key_exists($field->Relation, $variables)) {
				$variables[$field->Relation] = array();
			}
			$variables[$field->Relation][] = $field->toCode();
		}

		// Done.
		return $variables;
	}

	/**
	 * Generates a virtual class from scratch.
	 */
	protected function generateVirtualCode($class) {

		// Define the class.
		$code = sprintf("class %s extends DataObject {\n", $class);

		// Get the variables associated with the class.
		$variables = $this->getClassVariables($class);

		// Generate the code.
		foreach ($variables as $key => $values) {
			$code .= sprintf("\tprivate static \$%s = array(\n", $key);
			foreach ($values as $line_code) {
				$code .= "\t\t" . $line_code . ",\n";
			}
			$code .= "\t);\n";
		}

		// End of class.
		$code .= "}\n";

		return $code;
	}

	/**
	 * Generates additional code to append an existing class.
	 */
	protected function generateAdditionalCode($class) {
		// Define the class.
		$newclass = 'DataObjectCoachVirtualClass_' . $class;
		$code = sprintf(
			"class %s extends DataExtension {\n",
			$newclass
		);

		// Get the variables associated with the class.
		$variables = $this->getClassVariables($class);

		// Generate the code.
		foreach ($variables as $key => $values) {
			$code .= sprintf("\tprivate static \$%s = array(\n", $key);
			foreach ($values as $line_code) {
				$code .= "\t\t" . $line_code . ",\n";
			}
			$code .= "\t);\n";
		}

		// End of class.
		$code .= "}\n";

		// Add the extra line to config.
		$this->configlines[] = sprintf("Object::add_extension('%s', '%s');", addslashes($class), addslashes($newclass));

		return $code;
	}

	/**
	 * Gets the extra lines to go into _config.php.
	 */
	protected $configlines = array();
	protected function getExtraConfig() {
		return implode("\n", $this->configlines);
	}
}
